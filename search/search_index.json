{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"JSON Web Token Email Authentication pip install jwt-email-auth Documentation : https://mrthearman.github.io/jwt-email-auth/ Source Code : https://github.com/MrThearMan/jwt-email-auth/ Contributing : https://github.com/MrThearMan/jwt-email-auth/blob/main/CONTRIBUTING.md This module enables JSON Web Token Authentication in Django Rest framework without using Django's User model. Instead, login information is stored in cache , a login code is sent to the user's email inbox, and then the cached information is obtained using the code that was sent to the given email.","title":"Home"},{"location":"#json-web-token-email-authentication","text":"pip install jwt-email-auth Documentation : https://mrthearman.github.io/jwt-email-auth/ Source Code : https://github.com/MrThearMan/jwt-email-auth/ Contributing : https://github.com/MrThearMan/jwt-email-auth/blob/main/CONTRIBUTING.md This module enables JSON Web Token Authentication in Django Rest framework without using Django's User model. Instead, login information is stored in cache , a login code is sent to the user's email inbox, and then the cached information is obtained using the code that was sent to the given email.","title":"JSON Web Token Email Authentication"},{"location":"rotation/","text":"JWT rotation The library comes with a builtin Refresh token rotation system. This can be used to also return a new refresh token from the token refresh endpoint, and keep a log of the currently active token (a whitelist) via an inherited \"title\". Then, if a user, whether the real one or a malicious third party, tries to use a refresh token with that title, but that is currently not the active token in the log, all tokens with the given title will be invalidated. This strategy can help protect the old tokens from being reused. To use rotated refresh tokens, add the following settings: INSTALLED_APPS = [ ... \"jwt_email_auth.rotation\" , ... ] JWT_EMAIL_AUTH = { ... \"ROTATE_REFRESH_TOKENS\" : True , ... } Now you need to apply migration. Then, optionally, you can use the logout view to invalidate your refresh token when the user logs out. You might even consider using the update view to allow updating token claims after they are created. from django.urls import path from jwt_email_auth.views import LogoutView , UpdateTokenView urlpatterns = [ ... path ( \"logout/\" , LogoutView . as_view (), name = \"logout\" ), path ( \"update/\" , UpdateTokenView . as_view (), name = \"update\" ), ... ] Please think carefully the security implications of allowing token claims to be updated without re-authentication! You can control, which claims can be updated with the UPDATEABLE_CLAIMS setting.","title":"JWT Rotation"},{"location":"rotation/#jwt-rotation","text":"The library comes with a builtin Refresh token rotation system. This can be used to also return a new refresh token from the token refresh endpoint, and keep a log of the currently active token (a whitelist) via an inherited \"title\". Then, if a user, whether the real one or a malicious third party, tries to use a refresh token with that title, but that is currently not the active token in the log, all tokens with the given title will be invalidated. This strategy can help protect the old tokens from being reused. To use rotated refresh tokens, add the following settings: INSTALLED_APPS = [ ... \"jwt_email_auth.rotation\" , ... ] JWT_EMAIL_AUTH = { ... \"ROTATE_REFRESH_TOKENS\" : True , ... } Now you need to apply migration. Then, optionally, you can use the logout view to invalidate your refresh token when the user logs out. You might even consider using the update view to allow updating token claims after they are created. from django.urls import path from jwt_email_auth.views import LogoutView , UpdateTokenView urlpatterns = [ ... path ( \"logout/\" , LogoutView . as_view (), name = \"logout\" ), path ( \"update/\" , UpdateTokenView . as_view (), name = \"update\" ), ... ] Please think carefully the security implications of allowing token claims to be updated without re-authentication! You can control, which claims can be updated with the UPDATEABLE_CLAIMS setting.","title":"JWT rotation"},{"location":"setup/","text":"Setup \u2460 Add authentication, login and refresh views to urlpatterns. from django.urls import path from jwt_email_auth.views import SendLoginCodeView , LoginView , RefreshTokenView urlpatterns = [ ... path ( \"authentication/\" , SendLoginCodeView . as_view (), name = \"authentication\" ), path ( \"login/\" , LoginView . as_view (), name = \"login\" ), path ( \"refresh/\" , RefreshTokenView . as_view (), name = \"refresh\" ), ... ] \u2461 Configure settings with the JWT_EMAIL_AUTH key. Here is a minimal config (some values are defaults): JWT_EMAIL_AUTH = { \"SENDING_ON\" : True , # needs to be set explicitly! \"ACCESS_TOKEN_LIFETIME\" : timedelta ( minutes = 5 ), \"REFRESH_TOKEN_LIFETIME\" : timedelta ( days = 14 ), \"LOGIN_CODE_LIFETIME\" : timedelta ( minutes = 5 ), \"EXPECTED_CLAIMS\" : [ \"foo\" , \"bar\" ], \"CACHE_PREFIX\" : \"PREFIX\" , \"LOGIN_ATTEMPTS\" : 10 , \"LOGIN_COOLDOWN\" : timedelta ( minutes = 5 ), \"CODE_SEND_COOLDOWN\" : timedelta ( minutes = 1 ), \"LOGIN_VALIDATION_AND_DATA_CALLBACK\" : \"path.to.module.function\" , } Here are the rest of the settings and what they mean. Setting Description Type SENDING_ON Whether emails should be sent or not. When off, login code is logged instead (for development). bool SKIP_CODE_CHECKS When True, any code will work in login. bool SKIP_CODE_CHECKS_FOR List of emails for which code checks and email sending are off, even if SKIP_CODE_CHECKS=False and/or SENDING_ON=True. Useful for creating review accounts in an otherwise closed system. list[str] ACCESS_TOKEN_LIFETIME How long an access token is valid for. timedelta REFRESH_TOKEN_LIFETIME How long a refresh token is valid for. timedelta LOGIN_CODE_LIFETIME How long a login code is stored in cache. timedelta LOGIN_COOLDOWN After user has exceeded defined number of login attemprs, this is the cooldown until they can attempt login again. timedelta CODE_SEND_COOLDOWN After a user has sent a login code, this is the cooldown until they can send one again. timedelta NOT_BEFORE_TIME How long after the creation of the JWT does it become valid. timedelta ROTATE_REFRESH_TOKENS If True, return a new refresh token when requesting a new access token from RefreshTokenView. The old refresh token will be invalid after the new one is created. bool LOGIN_ATTEMPTS Number of login attempts until user is banned. int EXPECTED_CLAIMS List of expected JWT content. list[str] UPDATEABLE_CLAIMS Which expected claims can be updated without re-authentication using the update view. list[str] LOGIN_SENDING_EMAIL Email sender. str LOGIN_SUBJECT_LINE Email subject line. str LOGIN_EMAIL_MESSAGE Message to send in email. Must have {code} and {valid}! str LOGIN_EMAIL_HTML_TEMPLATE Path to html_message template. Context must have {{ code }} and {{ valid }}! Path CACHE_PREFIX Cache prefix. str OPTIONS_SCHEMA_ACCESS When True (default), OPTIONS requests can be made to the endpoint without token for schema access. bool CIPHER_KEY If set, JWT will be encrypted with AES in GCM-mode using this as the secret key. Should be either 16, 24, or 32 bytes, encoded to base64. str ISSUER Issuer of the JWT. str AUDIENCE Intended recipient of the JWT. str LEEWAY A time margin in seconds for the expiration check. int ALGORITHM Algorithm to sign and decrypt the token with. str HEADER_PREFIX Authorization scheme used in Authorization header, as in HEADER_PREFIX token . str EXTRA_HEADERS Additional JWT header fields. dict[str, str] These settings should be specified in \"dot import notation\" to a function, which will be imported as the value for the setting. Setting Description Arguments Returns SIGNING_KEY Function to load JWT signing key. ? CODE_GENERATOR Function to generate a login code. str SEND_LOGIN_CODE_CALLBACK Function that sends the login email. str, dict[str, Any], Request None LOGIN_VALIDATION_AND_DATA_CALLBACK Function to use for validating user and providing login data. str dict[str, Any] LOGIN_BLOCKER_CACHE_KEY_CALLBACK Function to generate cache key for storing user's login attempts. Request str USER_BLOCKED_ADDITIONAL_HANDLER Function for additional handling for blocked users. Request None USER_CHECK_CALLBACK Function to check if token user still exists in refresh view. RefreshToken None IP address spoofing prevention settings: Setting Description Type PROXY_ORDER Indicate whether the originating client is on the right or left in the X-Forwarded-For header \"left-most\" \"right-most\" PROXY_COUNT Number of proxies between the server and internet. int PROXY_TRUSTED_IPS Only these proxy IPs are allowed connections List[str] REQUEST_HEADER_ORDER Meta precedence order. List[str] Settings when using cookies: Setting Description Type USE_TOKENS If True, can authenticate with tokens in Authorization header. Set this to False and USE_COOKIES to True to only allow cookie authentication. bool USE_COOKIES If True, can authenticate with tokens in HttpOnly headers. Cookies will be checked before Authorization headers if they are enabled. bool DEFAULT_LOGIN_METHOD Default login method to use if none is given in Prefer-headers. If not set, cookie-based login will be used if enabled, else token-based. ACCESS_TOKEN_KEY Cookie key to use for the access token str REFRESH_TOKEN_KEY Cookie key to use for the refresh token str SET_COOKIE_SECURE Indicates that the cookie is sent to the server only when a request is made with the https: scheme (except on localhost) and therefore, is more resistant to man-in-the-middle attacks. bool SET_COOKIE_ACCESS_PATH Indicates the path that must exist in the requested URL for the browser to send the access token cookie. str SET_COOKIE_REFRESH_PATH Indicates the path that must exist in the requested URL for the browser to send the refresh token cookie. str SET_COOKIE_DOMAIN Defines the host to which the cookie will be sent. If None, this attribute defaults to the host of the current document URL, not including subdomains. str SET_COOKIE_HTTPONLY If True, forbids JavaScript from accessing the cookie. bool SET_COOKIE_SAMESITE Controls whether a cookie is sent with cross-origin requests, providing some protection against cross-site request forgery attacks (CSRF). \"lax\" \"strict\" \"none\" \u2462 Add OpenSSH based ed25519 SIGNING_KEY (in PEM format) to environment variables. You can create one with, e.g., ssh-keygen using the command ssh-keygen -t ed25519 . The linebreaks in PEM format should be replaced with | (pipe) characters. If you do not want to use environment variables, override the SIGNING_KEY setting. A default signing key is provided for reference in the settings-module, but this should be changed in production environments. \u2463 Configure Django's email settings (if using django's email sending): # Not all of these may be required EMAIL_HOST_USER = ... EMAIL_HOST_PASSWORD = ... EMAIL_HOST = ... EMAIL_PORT = ... EMAIL_USE_TLS = ... EMAIL_USE_SSL = ... EMAIL_BACKEND = ... EMAIL_SENDER = ... EMAIL_SUBJECT_PREFIX = ... DEFAULT_FROM_EMAIL = ... SERVER_EMAIL = ... \u2464 (Optional) Add default authentication_classes or permission_classes : REST_FRAMEWORK = { ... \"DEFAULT_AUTHENTICATION_CLASSES\" : [ \"jwt_email_auth.authentication.JWTAuthentication\" , ], \"DEFAULT_PERMISSION_CLASSES\" : [ \"jwt_email_auth.permissions.HasValidJWT\" , ] ... }","title":"Setup"},{"location":"setup/#setup","text":"\u2460 Add authentication, login and refresh views to urlpatterns. from django.urls import path from jwt_email_auth.views import SendLoginCodeView , LoginView , RefreshTokenView urlpatterns = [ ... path ( \"authentication/\" , SendLoginCodeView . as_view (), name = \"authentication\" ), path ( \"login/\" , LoginView . as_view (), name = \"login\" ), path ( \"refresh/\" , RefreshTokenView . as_view (), name = \"refresh\" ), ... ] \u2461 Configure settings with the JWT_EMAIL_AUTH key. Here is a minimal config (some values are defaults): JWT_EMAIL_AUTH = { \"SENDING_ON\" : True , # needs to be set explicitly! \"ACCESS_TOKEN_LIFETIME\" : timedelta ( minutes = 5 ), \"REFRESH_TOKEN_LIFETIME\" : timedelta ( days = 14 ), \"LOGIN_CODE_LIFETIME\" : timedelta ( minutes = 5 ), \"EXPECTED_CLAIMS\" : [ \"foo\" , \"bar\" ], \"CACHE_PREFIX\" : \"PREFIX\" , \"LOGIN_ATTEMPTS\" : 10 , \"LOGIN_COOLDOWN\" : timedelta ( minutes = 5 ), \"CODE_SEND_COOLDOWN\" : timedelta ( minutes = 1 ), \"LOGIN_VALIDATION_AND_DATA_CALLBACK\" : \"path.to.module.function\" , } Here are the rest of the settings and what they mean. Setting Description Type SENDING_ON Whether emails should be sent or not. When off, login code is logged instead (for development). bool SKIP_CODE_CHECKS When True, any code will work in login. bool SKIP_CODE_CHECKS_FOR List of emails for which code checks and email sending are off, even if SKIP_CODE_CHECKS=False and/or SENDING_ON=True. Useful for creating review accounts in an otherwise closed system. list[str] ACCESS_TOKEN_LIFETIME How long an access token is valid for. timedelta REFRESH_TOKEN_LIFETIME How long a refresh token is valid for. timedelta LOGIN_CODE_LIFETIME How long a login code is stored in cache. timedelta LOGIN_COOLDOWN After user has exceeded defined number of login attemprs, this is the cooldown until they can attempt login again. timedelta CODE_SEND_COOLDOWN After a user has sent a login code, this is the cooldown until they can send one again. timedelta NOT_BEFORE_TIME How long after the creation of the JWT does it become valid. timedelta ROTATE_REFRESH_TOKENS If True, return a new refresh token when requesting a new access token from RefreshTokenView. The old refresh token will be invalid after the new one is created. bool LOGIN_ATTEMPTS Number of login attempts until user is banned. int EXPECTED_CLAIMS List of expected JWT content. list[str] UPDATEABLE_CLAIMS Which expected claims can be updated without re-authentication using the update view. list[str] LOGIN_SENDING_EMAIL Email sender. str LOGIN_SUBJECT_LINE Email subject line. str LOGIN_EMAIL_MESSAGE Message to send in email. Must have {code} and {valid}! str LOGIN_EMAIL_HTML_TEMPLATE Path to html_message template. Context must have {{ code }} and {{ valid }}! Path CACHE_PREFIX Cache prefix. str OPTIONS_SCHEMA_ACCESS When True (default), OPTIONS requests can be made to the endpoint without token for schema access. bool CIPHER_KEY If set, JWT will be encrypted with AES in GCM-mode using this as the secret key. Should be either 16, 24, or 32 bytes, encoded to base64. str ISSUER Issuer of the JWT. str AUDIENCE Intended recipient of the JWT. str LEEWAY A time margin in seconds for the expiration check. int ALGORITHM Algorithm to sign and decrypt the token with. str HEADER_PREFIX Authorization scheme used in Authorization header, as in HEADER_PREFIX token . str EXTRA_HEADERS Additional JWT header fields. dict[str, str] These settings should be specified in \"dot import notation\" to a function, which will be imported as the value for the setting. Setting Description Arguments Returns SIGNING_KEY Function to load JWT signing key. ? CODE_GENERATOR Function to generate a login code. str SEND_LOGIN_CODE_CALLBACK Function that sends the login email. str, dict[str, Any], Request None LOGIN_VALIDATION_AND_DATA_CALLBACK Function to use for validating user and providing login data. str dict[str, Any] LOGIN_BLOCKER_CACHE_KEY_CALLBACK Function to generate cache key for storing user's login attempts. Request str USER_BLOCKED_ADDITIONAL_HANDLER Function for additional handling for blocked users. Request None USER_CHECK_CALLBACK Function to check if token user still exists in refresh view. RefreshToken None IP address spoofing prevention settings: Setting Description Type PROXY_ORDER Indicate whether the originating client is on the right or left in the X-Forwarded-For header \"left-most\" \"right-most\" PROXY_COUNT Number of proxies between the server and internet. int PROXY_TRUSTED_IPS Only these proxy IPs are allowed connections List[str] REQUEST_HEADER_ORDER Meta precedence order. List[str] Settings when using cookies: Setting Description Type USE_TOKENS If True, can authenticate with tokens in Authorization header. Set this to False and USE_COOKIES to True to only allow cookie authentication. bool USE_COOKIES If True, can authenticate with tokens in HttpOnly headers. Cookies will be checked before Authorization headers if they are enabled. bool DEFAULT_LOGIN_METHOD Default login method to use if none is given in Prefer-headers. If not set, cookie-based login will be used if enabled, else token-based. ACCESS_TOKEN_KEY Cookie key to use for the access token str REFRESH_TOKEN_KEY Cookie key to use for the refresh token str SET_COOKIE_SECURE Indicates that the cookie is sent to the server only when a request is made with the https: scheme (except on localhost) and therefore, is more resistant to man-in-the-middle attacks. bool SET_COOKIE_ACCESS_PATH Indicates the path that must exist in the requested URL for the browser to send the access token cookie. str SET_COOKIE_REFRESH_PATH Indicates the path that must exist in the requested URL for the browser to send the refresh token cookie. str SET_COOKIE_DOMAIN Defines the host to which the cookie will be sent. If None, this attribute defaults to the host of the current document URL, not including subdomains. str SET_COOKIE_HTTPONLY If True, forbids JavaScript from accessing the cookie. bool SET_COOKIE_SAMESITE Controls whether a cookie is sent with cross-origin requests, providing some protection against cross-site request forgery attacks (CSRF). \"lax\" \"strict\" \"none\" \u2462 Add OpenSSH based ed25519 SIGNING_KEY (in PEM format) to environment variables. You can create one with, e.g., ssh-keygen using the command ssh-keygen -t ed25519 . The linebreaks in PEM format should be replaced with | (pipe) characters. If you do not want to use environment variables, override the SIGNING_KEY setting. A default signing key is provided for reference in the settings-module, but this should be changed in production environments. \u2463 Configure Django's email settings (if using django's email sending): # Not all of these may be required EMAIL_HOST_USER = ... EMAIL_HOST_PASSWORD = ... EMAIL_HOST = ... EMAIL_PORT = ... EMAIL_USE_TLS = ... EMAIL_USE_SSL = ... EMAIL_BACKEND = ... EMAIL_SENDER = ... EMAIL_SUBJECT_PREFIX = ... DEFAULT_FROM_EMAIL = ... SERVER_EMAIL = ... \u2464 (Optional) Add default authentication_classes or permission_classes : REST_FRAMEWORK = { ... \"DEFAULT_AUTHENTICATION_CLASSES\" : [ \"jwt_email_auth.authentication.JWTAuthentication\" , ], \"DEFAULT_PERMISSION_CLASSES\" : [ \"jwt_email_auth.permissions.HasValidJWT\" , ] ... }","title":"Setup"},{"location":"usage/","text":"Usage Backend Send a login code to the authentication endpoint (from SendLoginCodeView class). Request Response POST [Authentication URI] Content-Type: application/json HTTP 204 NO CONTENT { \u2002\u2002\"email\":\"person@example.com\" } ... POST the login code and email to login endpoint (from LoginView class). Request Response POST [Login URI] Content-Type: application/json HTTP 200 OK { \u2002\u2002\"email\":\"person@example.com\" \u2002\u2002\"code\":\"123222\" } { \u2002\u2002\"access\":\"...\" \u2002\u2002\"refresh\":\"...\" } If both USE_TOKENS and USE_COOKIES are enabled, you can select the wanted login method via the Prefer header\u00b4. Set it to token or cookies to select one or the other. If not set, the value will be determined from DEFAULT_LOGIN_METHOD , but if this is not set the default will be cookies if cookies are enabled, and token if not. Refresh access token from the refresh token endpoint (from RefreshTokenView class). Request Response POST [Refresh Token URI] Content-Type: application/json HTTP 200 OK { \u2002\u2002\"token\":\"...\" } { \u2002\u2002\"access\":\"...\" \u2002\u2002\"refresh\":\"...\" } If ROTATE_REFRESH_TOKENS is in use, the given refresh token will be a new refresh token, and the old refresh token will no longer be valid. Otherwise, the token will be the same same token used on the endpoint. Authentication and Permission classes Add the JWTAuthentication or HasValidJWT to Rest framework's settings, or to the class's authentication_classes or permission_classes from rest_framework.views import APIView from jwt_email_auth.authentication import JWTAuthentication from jwt_email_auth.permissions import HasValidJWT class SomeView ( APIView ): authentication_classes = [ JWTAuthentication ] permission_classes = [ HasValidJWT ] ... Base Access Serializer If you need to use claims from the token in you code, you can use the BaseAccessSerializer . from rest_framework import serializers from rest_framework.views import APIView from jwt_email_auth.serializers import BaseAccessSerializer from jwt_email_auth.authentication import JWTAuthentication from jwt_email_auth.permissions import HasValidJWT class SomeSerializer ( BaseAccessSerializer ): take_from_token = [ \"example\" , \"values\" ] some = serializers . CharField () data = serializers . CharField () ... class SomeView ( APIView ): authentication_classes = [ JWTAuthentication ] permission_classes = [ HasValidJWT ] def post ( self , request , * args , ** kwargs ): data = { \"some\" : ... , \"data\" : ... } # Request is needed in serializer context to get the access token serializer = SomeSerializer ( data = data , context = { \"request\" , request }) serializer . is_valid ( raise_exception = True ) data = serializer . validated_data # ...or this # data = serializer.data print ( data ) # {\"some\": ..., \"data\": ..., \"example\": ..., \"values\": ...} ... Frontend To implement authentication with this library in the frontend, you'll need a way to call the SendLoginCodeView and LoginView for authentication, and then implement a way to automatically call RefreshTokenView when your access token expires or is about to expire. You'll also need to implement views/logic for all the possible error responses from each of these views. SendLoginCodeView 400: Input is incorrect 412: User is blocked from login due to too many attempts 503: Could not send login code LoginView 400: Input is incorrect 403: Given login code was incorrect 404: No login code has been sent for this user, or the code has expired 410: Login data was corrupted 412: User has been blocked due to too many attempts RefreshTokenView 400: Input is incorrect 403: Refresh token expired, or otherwise invalid 404: Refresh token user no longer exists (requires \"user_check=True\" in refresh view) When using the JWT in views using the JWTAuthentication and HasValidJWT authentication and permission classes, you need to always listen for 403 responses, and try to call RefreshTokenView in case the access token has expired. In case RefreshTokenView also returns 403, this usually means that the refresh token has also expired, and the user should be asked to re-authorize. In case you are using JWT rotation , when you call RefreshTokenView , the returned refresh token will also need to be saved, as the old one is invalidated. Using JWT rotation can save your users from having to reauthorize when their initial refresh token expires. flowchart TB start__enter_email('Enter email') user_blocked{Is user IP blocked?} check_email[Check given email from third party] fail__user_blocked[Error: User cannot send another login code yet] email_found{User with email found} send_login_code[Send login code to given email] fail__email_not_found[Error: Did not find user] start__enter_login_code['Enter login code'] fail__block_user[Error: Block user from loggin in for 5 minutes based on IP] fail__re_enter_login_code[Error: Wrong login code] resend_code[Resend code, invalidate previous one] can_resend{Can resend code?} fail__cannot_resend[Error: User cannot send another login code yet] login_code_correct{Valid code?} success__log_in(Log user in) too_many_attemps{Too many attempts?} start__enter_email --> |User enters their email| user_blocked user_blocked --> |no| check_email check_email --> email_found user_blocked --> |yes| fail__user_blocked fail__user_blocked --> start__enter_email email_found --> |yes| send_login_code email_found --> |no| fail__email_not_found fail__email_not_found --> start__enter_email send_login_code --> start__enter_login_code start__enter_login_code --> |Try another email| start__enter_email start__enter_login_code --> |User enters login code| login_code_correct start__enter_login_code --> |Resend code| can_resend can_resend --> |no| fail__cannot_resend can_resend --> |yes| resend_code resend_code --> start__enter_login_code fail__cannot_resend --> start__enter_login_code login_code_correct --> |yes| success__log_in login_code_correct --> |no| too_many_attemps too_many_attemps --> |no| fail__re_enter_login_code too_many_attemps --> |yes| fail__block_user fail__re_enter_login_code --> start__enter_login_code fail__block_user --> start__enter_email A flowchart describing a possible implementation. Non-email authentication Even though \"email\" is in the name of the library, it can be used to authenticate via other means, e.g., SMS. The library tries not to refer to email specifically, so that all documentation is still relevant if the authentication method is something other than email. All you'll need to do is create new serializers for SendLoginCodeView and LoginView which replace the \"email\" field with something else. Then, you can implement SEND_LOGIN_CODE_CALLBACK using that field's value. Here is an example using phone number for SMS authentication: # myapp/views.py from rest_framework import serializers from jwt_email_auth.serializers import BaseSendLoginCodeSerializer , BaseLoginSerializer from jwt_email_auth import views as jwt_views # Should have one field of any type class SendLoginCodeSerializer ( BaseSendLoginCodeSerializer ): phone = serializers . CharField ( help_text = \"Phone number to send the code to.\" ) # Should have one field of any type class LoginSerializer ( BaseLoginSerializer ): phone = serializers . CharField ( help_text = \"Phone number the code was sent to.\" ) class SendLoginCodeView ( jwt_views . SendLoginCodeView ): serializer_class = SendLoginCodeSerializer class LoginView ( jwt_views . LoginView ): serializer_class = LoginSerializer # myapp/utils.py from typing import Any from rest_framework.request import Request def send_login_code_via_sms ( phone : str , login_data : dict [ str , Any ], request : Request , ) -> None : ... # myproject/settings.py JWT_EMAIL_AUTH = { ... \"SEND_LOGIN_CODE_CALLBACK\" : \"myapp.utils.send_login_code_via_sms\" , ... }","title":"Usage"},{"location":"usage/#usage","text":"","title":"Usage"},{"location":"usage/#backend","text":"Send a login code to the authentication endpoint (from SendLoginCodeView class). Request Response POST [Authentication URI] Content-Type: application/json HTTP 204 NO CONTENT { \u2002\u2002\"email\":\"person@example.com\" } ... POST the login code and email to login endpoint (from LoginView class). Request Response POST [Login URI] Content-Type: application/json HTTP 200 OK { \u2002\u2002\"email\":\"person@example.com\" \u2002\u2002\"code\":\"123222\" } { \u2002\u2002\"access\":\"...\" \u2002\u2002\"refresh\":\"...\" } If both USE_TOKENS and USE_COOKIES are enabled, you can select the wanted login method via the Prefer header\u00b4. Set it to token or cookies to select one or the other. If not set, the value will be determined from DEFAULT_LOGIN_METHOD , but if this is not set the default will be cookies if cookies are enabled, and token if not. Refresh access token from the refresh token endpoint (from RefreshTokenView class). Request Response POST [Refresh Token URI] Content-Type: application/json HTTP 200 OK { \u2002\u2002\"token\":\"...\" } { \u2002\u2002\"access\":\"...\" \u2002\u2002\"refresh\":\"...\" } If ROTATE_REFRESH_TOKENS is in use, the given refresh token will be a new refresh token, and the old refresh token will no longer be valid. Otherwise, the token will be the same same token used on the endpoint.","title":"Backend"},{"location":"usage/#authentication-and-permission-classes","text":"Add the JWTAuthentication or HasValidJWT to Rest framework's settings, or to the class's authentication_classes or permission_classes from rest_framework.views import APIView from jwt_email_auth.authentication import JWTAuthentication from jwt_email_auth.permissions import HasValidJWT class SomeView ( APIView ): authentication_classes = [ JWTAuthentication ] permission_classes = [ HasValidJWT ] ...","title":"Authentication and Permission classes"},{"location":"usage/#base-access-serializer","text":"If you need to use claims from the token in you code, you can use the BaseAccessSerializer . from rest_framework import serializers from rest_framework.views import APIView from jwt_email_auth.serializers import BaseAccessSerializer from jwt_email_auth.authentication import JWTAuthentication from jwt_email_auth.permissions import HasValidJWT class SomeSerializer ( BaseAccessSerializer ): take_from_token = [ \"example\" , \"values\" ] some = serializers . CharField () data = serializers . CharField () ... class SomeView ( APIView ): authentication_classes = [ JWTAuthentication ] permission_classes = [ HasValidJWT ] def post ( self , request , * args , ** kwargs ): data = { \"some\" : ... , \"data\" : ... } # Request is needed in serializer context to get the access token serializer = SomeSerializer ( data = data , context = { \"request\" , request }) serializer . is_valid ( raise_exception = True ) data = serializer . validated_data # ...or this # data = serializer.data print ( data ) # {\"some\": ..., \"data\": ..., \"example\": ..., \"values\": ...} ...","title":"Base Access Serializer"},{"location":"usage/#frontend","text":"To implement authentication with this library in the frontend, you'll need a way to call the SendLoginCodeView and LoginView for authentication, and then implement a way to automatically call RefreshTokenView when your access token expires or is about to expire. You'll also need to implement views/logic for all the possible error responses from each of these views. SendLoginCodeView 400: Input is incorrect 412: User is blocked from login due to too many attempts 503: Could not send login code LoginView 400: Input is incorrect 403: Given login code was incorrect 404: No login code has been sent for this user, or the code has expired 410: Login data was corrupted 412: User has been blocked due to too many attempts RefreshTokenView 400: Input is incorrect 403: Refresh token expired, or otherwise invalid 404: Refresh token user no longer exists (requires \"user_check=True\" in refresh view) When using the JWT in views using the JWTAuthentication and HasValidJWT authentication and permission classes, you need to always listen for 403 responses, and try to call RefreshTokenView in case the access token has expired. In case RefreshTokenView also returns 403, this usually means that the refresh token has also expired, and the user should be asked to re-authorize. In case you are using JWT rotation , when you call RefreshTokenView , the returned refresh token will also need to be saved, as the old one is invalidated. Using JWT rotation can save your users from having to reauthorize when their initial refresh token expires. flowchart TB start__enter_email('Enter email') user_blocked{Is user IP blocked?} check_email[Check given email from third party] fail__user_blocked[Error: User cannot send another login code yet] email_found{User with email found} send_login_code[Send login code to given email] fail__email_not_found[Error: Did not find user] start__enter_login_code['Enter login code'] fail__block_user[Error: Block user from loggin in for 5 minutes based on IP] fail__re_enter_login_code[Error: Wrong login code] resend_code[Resend code, invalidate previous one] can_resend{Can resend code?} fail__cannot_resend[Error: User cannot send another login code yet] login_code_correct{Valid code?} success__log_in(Log user in) too_many_attemps{Too many attempts?} start__enter_email --> |User enters their email| user_blocked user_blocked --> |no| check_email check_email --> email_found user_blocked --> |yes| fail__user_blocked fail__user_blocked --> start__enter_email email_found --> |yes| send_login_code email_found --> |no| fail__email_not_found fail__email_not_found --> start__enter_email send_login_code --> start__enter_login_code start__enter_login_code --> |Try another email| start__enter_email start__enter_login_code --> |User enters login code| login_code_correct start__enter_login_code --> |Resend code| can_resend can_resend --> |no| fail__cannot_resend can_resend --> |yes| resend_code resend_code --> start__enter_login_code fail__cannot_resend --> start__enter_login_code login_code_correct --> |yes| success__log_in login_code_correct --> |no| too_many_attemps too_many_attemps --> |no| fail__re_enter_login_code too_many_attemps --> |yes| fail__block_user fail__re_enter_login_code --> start__enter_login_code fail__block_user --> start__enter_email A flowchart describing a possible implementation.","title":"Frontend"},{"location":"usage/#non-email-authentication","text":"Even though \"email\" is in the name of the library, it can be used to authenticate via other means, e.g., SMS. The library tries not to refer to email specifically, so that all documentation is still relevant if the authentication method is something other than email. All you'll need to do is create new serializers for SendLoginCodeView and LoginView which replace the \"email\" field with something else. Then, you can implement SEND_LOGIN_CODE_CALLBACK using that field's value. Here is an example using phone number for SMS authentication: # myapp/views.py from rest_framework import serializers from jwt_email_auth.serializers import BaseSendLoginCodeSerializer , BaseLoginSerializer from jwt_email_auth import views as jwt_views # Should have one field of any type class SendLoginCodeSerializer ( BaseSendLoginCodeSerializer ): phone = serializers . CharField ( help_text = \"Phone number to send the code to.\" ) # Should have one field of any type class LoginSerializer ( BaseLoginSerializer ): phone = serializers . CharField ( help_text = \"Phone number the code was sent to.\" ) class SendLoginCodeView ( jwt_views . SendLoginCodeView ): serializer_class = SendLoginCodeSerializer class LoginView ( jwt_views . LoginView ): serializer_class = LoginSerializer # myapp/utils.py from typing import Any from rest_framework.request import Request def send_login_code_via_sms ( phone : str , login_data : dict [ str , Any ], request : Request , ) -> None : ... # myproject/settings.py JWT_EMAIL_AUTH = { ... \"SEND_LOGIN_CODE_CALLBACK\" : \"myapp.utils.send_login_code_via_sms\" , ... }","title":"Non-email authentication"}]}